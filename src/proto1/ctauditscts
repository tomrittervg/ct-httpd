#!/usr/bin/env python
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import binascii
import os
import struct
import sys

SERVER_START = 1
KEY_START = 2
CERT_START = 3
SCT_START = 4

def usage():
   print >> sys.stderr, 'Usage: %s /root/of/httpd/audit/files' % sys.argv[0]
   sys.exit(1)


def audit(fn, tmp, already_checked):
   print 'Auditing %s...' % fn

   tmp_leaf_der_fn = os.path.join(tmp, 'leaf.der.tmp')
   tmp_leaf_pem_fn = os.path.join(tmp, 'leaf.pem.tmp')

   # First, parse the audit file into a series of related
   #
   #   1. PEM file with certificate chain
   #      (TODO: teach verify_single_proof to accept DER)
   #   2. Individual SCT files
   #
   # Next,  for each SCT, invoke verify_single_proof to verify.
   bytes = open(fn, 'rb').read()
   offset = 0
   while offset < len(bytes):
      print 'Got package from server...'
      val = struct.unpack_from('>H', bytes, offset)
      assert val[0] == SERVER_START
      offset += 2

      assert struct.unpack_from('>H', bytes, offset)[0] == KEY_START
      offset += 2

      key_size = struct.unpack_from('>h', bytes, offset)[0]
      assert key_size > 0
      offset += 2

      key = bytes[offset:offset + key_size]
      offset += key_size

      # at least one certificate
      assert struct.unpack_from('>H', bytes, offset)[0] == CERT_START

      # for each certificate:
      leaf = None
      while struct.unpack_from('>H', bytes, offset)[0] == CERT_START:
         offset += 2
         val = struct.unpack_from('BBB', bytes, offset)
         offset += 3
         der_size = (val[0] << 16) | (val[1] << 8) | (val[2] << 0)
         print '  Certificate size:', hex(der_size)
         if not leaf:
            leaf = (offset, der_size)
         offset += der_size

      with open(tmp_leaf_der_fn, 'wb') as tmp_leaf:
         tmp_leaf.write(bytes[leaf[0]:leaf[0]+leaf[1]])

      # XXX modify verification program to accept DER
      cmd = 'openssl x509 -inform der -in %s -out %s' % (tmp_leaf_der_fn, tmp_leaf_pem_fn)
      print '>%s<' % cmd
      os.system(cmd)

      # at least one SCT
      assert struct.unpack_from('>H', bytes, offset)[0] == SCT_START

      # for each SCT:
      while offset < len(bytes) and struct.unpack_from('>H', bytes, offset)[0] == SCT_START:
         offset += 2
         len_offset = offset
         sct_size = struct.unpack_from('>H', bytes, len_offset)[0]
         offset += 2
         print '  SCT size:', hex(sct_size)
         log_id = bytes[offset + 1:offset + 1 + 32]
         print '    Log id: %s' % binascii.hexlify(log_id)
         timestamp_ms = struct.unpack_from('>Q', bytes, offset + 33)[0]
         print '    Timestamp: %s' % timestamp_ms

         #  If we ever need the full SCT: sct = (offset, sct_size)
         offset += sct_size

         if key in already_checked:
            print '  (SCTs already checked)'
            continue

         already_checked[key] = True

         cmd = 'verify_single_proof.py --cert %s --timestamp %s' % (tmp_leaf_pem_fn, timestamp_ms)
         print '>%s<' % cmd
         os.system(cmd)

def main():
   if len(sys.argv) != 2:
      usage()

   top = sys.argv[1]
   tmp = '/tmp'

   already_checked = dict()

   for dirpath, dnames, fnames in os.walk(top):
      fnames = [fn for fn in fnames if fn[-4:] == '.out']
      for fn in fnames:
         audit(os.path.join(dirpath, fn), tmp, already_checked)

if __name__ == "__main__":
   main()
