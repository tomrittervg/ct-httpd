#!/usr/bin/env python
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sqlite3
import sys


def create_tables(db_name):
    cxn = sqlite3.connect(db_name)
    cur = cxn.cursor()

    cur.execute('CREATE TABLE loginfo('
              + 'id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, '
              + 'public_key TEXT, '  # path to PEM-encoded file
              + 'audit_status TEXT, '  # 'F' for Failed-audit
              + 'url TEXT)') 
    cur.close()
    cxn.commit()
    cxn.close()


def record_id_arg(cur, args, required=False):
    if len(args) < 1 or args[0][0] != '#' or len(args[0]) < 2:
        if required:
            print >> sys.stderr, 'A record id was not provided'
            sys.exit(1)
        return None
    record_id = args.pop(0)[1:]
    stmt = 'SELECT * FROM loginfo WHERE id = ?'
    cur.execute(stmt, [record_id])
    recs = list(cur.fetchall())
    assert len(recs) < 2
    if len(recs) == 0:
        print >> sys.stderr, 'Record #%s was not found' % record_id
        sys.exit(1)
    return record_id


def public_key_arg(args):
    if len(args) < 1:
        print >> sys.stderr, 'A public key file was not provided'
        sys.exit(1)
    pubkey = args.pop(0)
    if not os.path.exists(pubkey):
        print >> sys.stderr, 'Public key file %s could not be read' % pubkey
        sys.exit(1)
    return pubkey


def configure_public_key(cur, args):
    record_id = record_id_arg(cur, args, False)
    public_key = public_key_arg(args)
    if len(args) != 0:
        usage()
    if not record_id:
        stmt = 'INSERT INTO loginfo (public_key) VALUES(?)'
        cur.execute(stmt, [public_key])
    else:
        stmt = 'UPDATE loginfo SET public_key = ? WHERE id = ?'
        cur.execute(stmt, [public_key, record_id])


def configure_url(cur, args):
    record_id = record_id_arg(cur, args, False)
    if len(args) != 1:
        usage()
    url = args.pop(0)
    if not record_id:
        stmt = 'INSERT INTO loginfo (url) VALUES(?)'
        cur.execute(stmt, [url])
    else:
        stmt = 'UPDATE loginfo SET url = ? WHERE id = ?'
        cur.execute(stmt, [url, record_id])


def forget_log(cur, args):
    record_id = record_id_arg(cur, args, True)
    if len(args) != 0:
        usage()
    stmt = 'DELETE FROM loginfo WHERE id = ?'
    cur.execute(stmt, [record_id])


def trust_distrust_log(cur, args):
    record_id = record_id_arg(cur, args, True)
    if len(args) != 1:
        usage()
    flag = args.pop(0)
    stmt = 'UPDATE loginfo SET audit_status = ? WHERE id = ?'
    cur.execute(stmt, [flag, record_id])


def trust_log(cur, args):
    trust_distrust_log(cur, args + ['T'])


def distrust_log(cur, args):
    trust_distrust_log(cur, args + ['F'])


def dump(cur, args):
    if len(args) != 0:
        usage()
    stmt = 'SELECT * FROM loginfo'
    cur.execute(stmt)
    for row in cur.fetchall():
        if row[1]:
            pubkey = row[1]
        else:
            pubkey = '(not configured)'
        if row[2]:
            if row[2].upper() == 'F':
                status = 'DISTRUSTED'
            elif row[2].upper() == 'T':
                status = 'trusted'
            else:
                # blow up, unexpected value
                assert row[2].upper() == 'F'
                status = 'junk'  # quiet lint
        else:
            status = 'trusted (by default)'

        if row[3]:
            url = row[3]
        else:
            url = '(not configured)'
        print 'Log entry:'
        print '  Record ' + str(row[0])
        print '  Status         : ' + status
        print '  Public key file: ' + pubkey
        print '  URL            : ' + url
        print ''


def usage():
    print >> sys.stderr, 'Usage: %s /path/to/log-config-db command args' % sys.argv[0]
    print >> sys.stderr, 'Commands:'
    print >> sys.stderr, '  dump                                                          display config-db contents'
    print >> sys.stderr, '  configure-public-key [record-id] /path/to/log-public-key.pem  configure public key'
    print >> sys.stderr, '  configure-url [record-id] http://www.example.com/path/        configure URL'
    print >> sys.stderr, '  trust record-id                                               mark log as trusted (default)'
    print >> sys.stderr, '  distrust record-id                                            mark log as untrusted'
    print >> sys.stderr, '  forget record-id                                              remove log from config-db'
    print >> sys.stderr, 'record-id references an existing entry and is in the form:'
    print >> sys.stderr, '  #<record-number>'
    print >> sys.stderr, '  (displayable with the dump command)'
    sys.exit(1)


def main():
    if len(sys.argv) < 3:
        usage()

    db_name = sys.argv[1]
    cmd = sys.argv[2]
    args = sys.argv[3:]

    cmds = {'configure-public-key': configure_public_key,
            'configure-url': configure_url,
            'distrust': distrust_log,
            'trust': trust_log,
            'forget': forget_log,
            'dump': dump,
        }

    cmds_requiring_db = ['dump', 'forget']  # db must already exist

    if not cmd in cmds:
        usage()

    if not os.path.exists(db_name):
        if not cmd in cmds_requiring_db:
            create_tables(db_name)
        else:
            print >> sys.stderr, 'Database "%s" does not exist' % db_name
            sys.exit(1)

    cxn = sqlite3.connect(db_name)
    cur = cxn.cursor()

    cmds[cmd](cur, args)

    cur.close()
    cxn.commit()
    cxn.close()

if __name__ == "__main__":
    main()
